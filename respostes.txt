ZeOS hanged?
- yes
which assembler instruction is executing?
- 'jmp 100000 <main>' jump to the same addres as this instruction
Where is the previous instruction located in the code?
- it is located in address 100000 and comes from 'while(1) { }' in the user.c
Can you see the generated code of the function add?
- '''
0000011d <add>:
 11d:	55                   	push   %ebp
 11e:	89 e5                	mov    %esp,%ebp
 120:	8b 45 0c             	mov    0xc(%ebp),%eax
 123:	03 45 08             	add    0x8(%ebp),%eax
 126:	5d                   	pop    %ebp
 127:	c3                   	ret
  '''
Now execute "objdump -d user". Do the addresses match? Why?
- '''
0010013f <add>:
  10013f:	55                   	push   %ebp
  100140:	89 e5                	mov    %esp,%ebp
  100142:	8b 45 0c             	mov    0xc(%ebp),%eax
  100145:	03 45 08             	add    0x8(%ebp),%eax
  100148:	5d                   	pop    %ebp
  100149:	c3                   	ret    
  10014a:	66 90                	xchg   %ax,%ax
  10014c:	66 90                	xchg   %ax,%ax
  10014e:	66 90                	xchg   %ax,%ax
  '''
  They do not match because 'user.o' has not alignment so code addresses start
  from 0x00 but 'user' is aligned to section 0x100000 so thats why they are
  not equal

Run the whole program in the bochs debugger (continue command). To regain control in the
debugger you have to type Ctrl+C. After doing so, which line is going to be executed?.
- 0x0010003b

Take a look at the dissasemble code from user file again. Can you see the invoking call
to the function add?
- No, this happens because of flag 'O2' that optimizes the code so this is eluded
Can you solve the problem?
- Yes by making user.o compiled without 'O2'


How is the dynamic link generated?


How are the parameters accessed?
- The parameters are accessed in the stack of the function:
    mov    0x8(%ebp),%edx
    mov    0xc(%ebp),%eax
How is the result returned?
- the result value is put in the eax register because it is the return register:
    add    %edx,%eax

Which  address  did  you  enter  in  the  Bochs  debugger  to  access  the  variable
that  stores  the resulting value from the add function?


